### Задание 3. Буферизированный ввод-вывод

В этом задании требуется реализовать буферизованное чтение из сокета и буферизованную запись, а затем провести юнит-тестирование.


### Какую проблему решаем?

Рассмотрим следующий код:

```
// read all data from socket
int read_bytes;
while ((read_bytes = read(conn_fd, buf, sizeof(buf)) > 0) {
    buffer.insert(buffer.end(), buf, buf + read_bytes);
}
```

Цикл будет выполняться до тех пор, пока не выполнится одно из следующих условий:
 * произойдет ошибка чтения из сокета
 * клиент отправит все данные и закроет соединение

В тестах на echo-сервер (задание 1) клиент закрывает соединение на запись сразу после отправки
сообщения, поэтому подобный цикл в вашей реализации задания успешно завершается.
В сервере memcached, однако, нельзя использовать такой подход, потому что клиент *не закрывает*
соединение на запись после отправки сообщения, а держит его открытым долгое время. Это позволяет
экономить время на открытии соединения и добиться большей производительности.

Тогда возникает вопрос, как же прочитать сообщение клиента целиком и обработать его?

Если бы была известна длина сообщения, то проблема снова решалась бы просто, например, таким
фрагментом кода:

```
int message_len = 10000;  // известная длина сообщения

int to_read = message_len;
while (to_read > 0 && (read_bytes = read(conn_fd, buf, sizeof(buf)) > 0) {
    buffer.insert(buffer.end(), buf, buf + read_bytes);
    to_read -= read_bytes;
}

if (read_bytes == message_len) {
    // обработка сообщения
} else {
    // прочитали не все сообщение!
}
```

Но в протоколе memcached, прежде чем найти длину сообщения, необходимо сначала проанализировать его
(распарсить), найти длину блока с данными, и только потом узнать длину.

Для решения проблемы, придется отказаться от схемы, при которой мы сначала читаем целиком все
сообщение в `std::vector<char>`, а затем обрабатываем его.

Вместо этого сделаем класс, который по запросу будет считывать нужное количество данных.

```
class RBuffer {
public:
    // конструктор, деструктор...

    char ReadChar();
    void ReadCharCheck(char check);
    uint32_t ReadUint32();

    std::string ReadField(char sep);  // reads all data before 'sep' into string
    std::vector<char> ReadBytes(size_t bytes_num);

protected:
    ...
};
```

Рассмотрим подробнее, что делают методы этого класса.

Методы `ReadChar` и `ReadCharCheck` счиывают один символ (второй метод дополнительно проверяет, что этот символ равен ожидаемому).

Метод `ReadUint32` считывает число (после числа в потоке обязан быть хотя бы один символ, не являющийся цифрой).

Метод `ReadField` считывает последовательность символов до тех пор, пока не встретится символ,
    равный `sep`.
Например,
```
std::string key = rbuffer.ReadField(' ');
```

считает последовательность непробельных символов в строку `key`.

Метод `ReadBytes` считывает последовательность символов длины `bytes_num`.
Он может использоваться, когда длина сообщения уже известна.

### Но при чем тут буферизация?

Те же самые методы можно реализовать, если считывать из потока каждый раз по 1 символу. Но это очень
неэффективно. Гораздо эффективнее считывать сразу по много символов и экономить тем самым время на
осуществление системного вызова.

Как выбрать размер буфера -- не такая простая задача. Если выбрать слишком маленький размер, то
выигрыш будет невелик. Если выбрать слишком большой размер, то во-первых расход памяти будет
большим, во-вторых клиент может слать данные маленькими порциями, и вместо того, чтобы обработать
то, что уже пришло, мы будем "зависать", ожидая, когда большая порция данных придет целиком.
Универсальный совет здесь -- выбирать размер буфера по результатам нагрузочного тестирования
программы.

Поэтому логика работы буферизированного чтения такая:
* прочитать в буфер min(длина буфера, количество данных в сокете) байт
* при вызове функций ReadX считывать данные из буфера, сдвигая курсор текущего чтения (переменная `pos_`)
* если дошли до конца буфера, обновить содержимое буфера

### Задание

Классы RBuffer и WBuffer вам уже были даны для реализации второго задания. Также вам были даны
наследники этих классов StringRBuffer и StringWBuffer, реализующие буферизированное
чтение из строки (они не имеют большого практического смысла и нужны скорее для иллюстрации).

Вам нужно реализовать классы SocketRBuffer и SocketWBuffer, который будут являться наследниками
соответственно RBuffer и WBuffer и реализовывать буферизированное чтение из сокета.
Нужно переопределить виртуальную функцию `ReadMore` и создать конструктор с двумя параметрами:
файловый дескриптор и размер буфера.

Также нужно написать юнит-тесты на эти два класса.

Юнит-тесты можно добавлять в новый файл `ut/socket_buffer_ut.cpp`.

Рекомендации по написанию тестов:

 * На классы `SocketRBuffer` и `SocketWBuffer` нужно создавать разные тесты
 * Для создания в тестах классов `SocketRBuffer` и `SocketWBuffer` можно использовать функцию `int
 * pipe(int fd[2])`. Эта функция заполняет массив из 2 файловых дескрипторов, один из которых(fd[0])
можно использовать для чтения, а fd[1] -- для записи.
 * Допустим, вы тестируете класс `SocketRBuffer`. Тогда можно в конструктор SocketRBuffer
передать fd[0] в качестве дескрипотра, и записать какие-то данные в fd[1] с помощью `write`. Затем считать данные из
SocketRBuffer с помощью одного из методов и проверить, что данные не изменились.
Варьируйте: размер буфера и размер передаваемых данных; количество вызовов `write`.
Смоделируйте ситуацию чтения из пустого буфера.
